"use strict"
/**
 * @file keyboard
 * @author Frédéric BISSON <zigazou@free.fr>
 * @version 1.0
 *
 * Keyboard simulates a Minitel keyboard from a standard keyboard.
 */

/**
 * @namespace Minitel
 */
var Minitel = Minitel || {}

/**
 * The EmitterHandler callback handles code sequences generated by a Keyboard
 * object.
 * @name EmitterHandler
 * @function
 * @param {Int[]} sequence Minitel code sequence
 */

/**
 * The ConfigHandler callback handles settings changes.
 * @name ConfigHandler
 * @function
 * @param {Object} settings Settings value
 */

/**
 * Keyboard converts keys received by the browser into Minitel keys.
 */
Minitel.Keyboard = class {
    /**
     * @param {HTMLElement} container Element containing all keyboard elements.
     * @param {EmitterHandler?} emitter An emitter handler that will be called
     *                                  everytime a key generates Minitel codes.
     * @param {ConfigHandler?} emitter A config handler that will be called
                                       everytime the user changes a setting.
     */
    constructor(container, emitter, config) {
        /**
         * Remembers if the ctrl key is down.
         * @member {boolean}
         * @private
         */
        this.kCtrl = false

        /**
         * Remembers if the shift key is down.
         * @member {boolean}
         * @private
         */
        this.kShift = false

        /**
         * Remembers if the fnct key is down.
         * @member {boolean}
         * @private
         */
        this.kFnct = false

        /**
         * Does the keyboard works in extended mode?
         * @member {boolean}
         * @private
         */
        this.kExtended = false

        /**
         * Does the keyboard generates code for the cursor keys?
         * @member {boolean}
         * @private
         */
        this.kCursorKeys = false

        /**
         * Does the keyboard works in uppercase mode? (default mode of Minitel)
         * @member {boolean}
         * @private
         */
        this.kUppercase = true

        /**
         * The EmitterHandler associated with the keyboard.
         * @member {EmitterHandler}
         * @private
         */
        this.emitter = undefined
        this.setEmitter(emitter)

        /**
         * The ConfigHandler associated with the keyboard.
         * @member {ConfigHandler}
         * @private
         */
        this.config = undefined
        this.setConfig(config)

		this.save = false;
		this.paused = false;
		this.saveArr = []
		
        // Look for all elements
        const elements = new Minitel.Elements()
        elements.add('keyalpha')
                .add('keynonalpha')
                .add('keyconfig')
                .add('keysound')
                .foundIn(container)

        /**
         * The alphabetical keys page.
         * @member {HTMLElement}
         * @private
         */
        this.pageAlpha = elements.keyalpha

        /**
         * The non-alphabetical keys page.
         * @member {HTMLElement}
         * @private
         */
        this.pageNAlpha = elements.keynonalpha

        /**
         * The config page.
         * @member {HTMLElement}
         * @private
         */
        this.pageConfig = elements.keyconfig

        /**
         * The key simulator.
         * @member {KeySimulator}
         * @private
         */
        this.simulator = elements.keysound
                       ? new KeySimulator(elements.keysound)
                       : undefined

        // Install events listener
        document.addEventListener("keyup", event => this.onkeyup(event))
        document.addEventListener("keydown", event => this.onkeypress(event))
        container.autocallback(this)
    }

download() {
	var binString='';
    var pom = document.createElement('a');
    //pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(this.saveArr));
	
    range(this.saveArr.length).forEach(i =>
       binString+=String.fromCharCode(this.saveArr[i])
    )
	
	
	//pom.setAttribute('href', 'data:application/octet-stream,' + binString);
	pom.setAttribute('href', 'data:application/octet-stream,' + encodeURIComponent(binString));
    pom.setAttribute('download', 'page.vdt');

    if (document.createEvent) {
        var event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        pom.dispatchEvent(event);
    }
    else {
        pom.click();
    }
}



    /**
     * Defines an EmitterHandler which will be called everytime a key is
     * is pressed.
     * @member {EmitterHandler}
     */
    setEmitter(emitter) {
        this.emitter = emitter
    }

    /**
     * Handles key press events.
     * @private
     */
    keypress(keycodes) {
        if(this.emitter && keycodes !== null) {
            this.emitter(keycodes)
        }
    }

    /**
     * Defines a ConfigHandler which will be called everytime a setting is
     * changed by the user.
     * @member {ConfigHandler}
     */
    setConfig(config) {
        this.config = config
    }

    /**
     * Select the speed on the config form.
     * @param {string} speed "1200", "4800", "9600" or "FULL"
     */
    selectSpeed(speed) {
        this.pageConfig.querySelector('.config-speed>select').value = speed
    }

    /**
     * Select the color on the config form.
     * @param {string} color "true" or "false"
     */
    selectColor(color) {
        this.pageConfig.querySelector('.config-color>select').value = color
    }

	
    /**
     * Handles settings changes.
     * @param {HTMLEvent} event
     * @param {string} param
     * @private
     */
    onSettingChanged(event) {
        if(this.config === undefined) return

        const speed = event.target.querySelector('.config-speed>select').value
        const color = event.target.querySelector('.config-color>select').value

        this.config({
            speed: speed === "FULL" ? 0 : parseInt(speed),
            color: color === "true"
        })
    }

    /**
     * Handles Alpha button event.
     * @private
     */
    onAlpha() {
        this.pageNAlpha.classList.add("hidden")
        this.pageConfig.classList.add("hidden")
        this.pageAlpha.classList.remove("hidden")
    }

    /**
     * Handles NAlpha button event.
     * @private
     */
    onNAlpha() {
        this.pageAlpha.classList.add("hidden")
        this.pageConfig.classList.add("hidden")
        this.pageNAlpha.classList.remove("hidden")
    }

    /**
     * Handles Config button event.
     * @private
     */
    onConfig() {
        this.pageAlpha.classList.add("hidden")
        this.pageNAlpha.classList.add("hidden")
        this.pageConfig.classList.remove("hidden")
    }

    /**
     * Handles key up events.
     * @private
     */
    onkeyup(event) {
        event.preventDefault()
    }

    /**
     * Handles key press events.
     * @private
     */
    onkeypress(event) {
        this.kShift = event.shiftKey
        this.keypress(this.toMinitel(event.key))
        event.preventDefault()
    }

    /**
     * Handles click events.
     * @private
     */
    onclick(event, param) {
        // Make a sound
        if(this.simulator) {
            this.simulator.pressKey(param)
        }

        if(param === "Maj") {
            this.kShift = !this.kShift
        }

		if (param === "Sauve") {
			this.save = !this.save;
			if (this.save) {
				event.target.innerText = 'Arrêt enr.';			
			} else { 
				event.target.innerText = 'Début enr.';			
				this.download();
				this.saveArr = [];
			}
		}
		if (param === "Pause") {
			this.paused = !this.paused;
			if (this.paused) {
				event.target.innerText = '⏵';			
			} else { 
				event.target.innerText = '⏸';			
			}
		}
		
		if (param === "Espace") {
			this.keypress(this.toMinitel(' '));
		}
        this.keypress(this.toMinitel(param))
    }

    /**
     * Set the uppercase mode of the keyboard
     * @param {boolean} bool true indicates the keyboard operates in uppercase
     *                       false indicates the keyboard operates in lowercase
     */
    setUppercaseMode(bool) {
        this.kUppercase = bool
    }

    /**
     * Set the extended mode of the keyboard
     * @param {boolean} bool true indicates the keyboard works extended
     *                       false indicates the keyboard works standard
     */
    setExtendedMode(bool) {
        this.kExtended = bool
    }

    /**
     * Set the cursor keys of the keyboard
     * @param {boolean} bool true indicates keyboard use cursor keys
     *                       false indicates keyboard does not use cursor keys
     */
    setCursorKeys(bool) {
        this.kCursorKeys = bool
    }

    /**
     * Converts a key to a Minitel code sequence according to the current state
     * of the keyboard.
     * @param {String} key A string identifying a key.
     * @return {Int[]} The Minitel code sequence corresponding or null if the
     *                 key cannot be converted.
     */
    toMinitel(key) {
        if(key.length === 1) {
            // Handles uppercase mode and shift key
            if(this.kUppercase !== this.kShift) {
                key = key.toUpperCase()
            } else {
                key = key.toLowerCase()
            }
        } else {
			
            if(key in Minitel.pcToMinitelKeys) {
                key = Minitel.pcToMinitelKeys[key]
            }
        }

        if(key in Minitel.keys.Videotex) {
            return Minitel.keys.Videotex[key]
        }

        return null
    }
}
