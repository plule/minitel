"use strict"
/**
 * @file generichelper.js
 * @author Frédéric BISSON <zigazou@free.fr>
 * @version 1.0
 */

/**
 * @callback ForEachFunction
 * @param {number} i The index generated by the range function
 */

/**
 * @callback ForEachFunction2
 * @param {number} j The outer index generated by the range2 function
 * @param {number} i The inner index generated by the range2 function
 */

/**
 * The range function generates numbers from a start value to an end value (not
 * included) with an optional step. It helps replacing for loops by something
 * with a more functional approach.
 *
 * If the end value is not given, it will count from 0 to the start value (not
 * included).
 *
 * If end value is inferior to start value, it will count from start down to
 * end.
 * 
 * A non-specified step is equivalent to 1.
 *
 * @param {number} start The start value
 * @param {number=} end The end value (not included)
 * @param {number=} step The optional step
 */
function* range(start, end, step) {
    if(start === undefined || start === end) return

    if(end === undefined) {
        end = start
        start = 0
    }

    if(step === undefined) step = 1

    step = Math.abs(step)

    if(end < start) {
        for(let i = start; i > end; i -= step) yield i
    } else {
        for(let i = start; i < end; i += step) yield i
    }
}

/**
 * The forEach method allows one to write loops like `range(100).forEach(func)`
 * where `func` is a function accepting one argument.
 *
 * @param {ForEachFunction} The function to be executed for each value generated
 *                          by the `range` function
 */
range().__proto__.forEach = function(func) {
    for(let i of this) func(i)
}

/**
 * The range2 function works like the range function but with 2 imbricated
 * generators. It helps replacing double for loops by something with a more
 * functional approach.
 *
 * @param {number[]} start The starting values
 * @param {number[]=} end The end values (not included)
 * @param {number[]=} step The optional steps
 */
function* range2(starts, ends, steps) {
    if(starts === undefined) return

    if(ends === undefined) {
        ends = starts
        starts = [ 0, 0 ]
    }

    if(steps === undefined) steps = [ 1, 1 ]

    const [ jStart, iStart ] = starts
    const [ jEnd, iEnd ] = ends
    const [ jStep, iStep ] = [
        Math.abs(steps[0]) * (jStart <= jEnd ? 1 : -1),
        Math.abs(steps[1]) * (iStart <= iEnd ? 1 : -1),
    ]

    if(jStart <= jEnd && iStart <= iEnd) {
        for(let j = jStart; j < jEnd; j += jStep) {
            for(let i = iStart; i < iEnd; i += iStep) {
                yield [j, i]
            }
        }
        return    
    }

    if(jStart <= jEnd && iStart > iEnd) {
        for(let j = jStart; j < jEnd; j += jStep) {
            for(let i = iStart; i > iEnd; i += iStep) {
                yield [j, i]
            }
        }
        return    
    }

    if(jStart > jEnd && iStart <= iEnd) {
        for(let j = jStart; j > jEnd; j += jStep) {
            for(let i = iStart; i < iEnd; i += iStep) {
                yield [j, i]
            }
        }
        return    
    }

    for(let j = jStart; j > jEnd; j += jStep) {
        for(let i = iStart; i > iEnd; i += iStep) {
            yield [j, i]
        }
    }
}

/**
 * The forEach method allows one to write loops like `range(5,10).forEach(func)`
 * where `func` is a function accepting one argument.
 *
 * @param {ForEachFunction2} The function to be executed for each value
 *                           generated by the `range2` function
 */
range2().__proto__.forEach = function(func) {
    for(let [ j, i ] of this) func(j, i)
}

/**
 * Repeat `count` times an `item` in an array
 * @param {} item An item to be repeated
 * @param {number} count The number of times the item is repeated
 */
function repeat(item, count) {
    const array = new Array(count)
    for(let i = 0; i < count; i++) array[i] = item
    return array
}
